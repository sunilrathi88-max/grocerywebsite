/**
 * Authentication Service
 * Handles JWT tokens, authentication state, and API integration
 */

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number; // seconds
  tokenType: 'Bearer';
}

export interface AuthUser {
  id: number;
  email: string;
  name: string;
  isAdmin: boolean;
  isEmailVerified: boolean;
  has2FA: boolean;
  profilePicture?: string;
  createdAt?: string;
}

export interface LoginResponse {
  success: boolean;
  user: AuthUser;
  tokens: AuthTokens;
  message?: string;
  requires2FA?: boolean;
}

export interface SignUpResponse {
  success: boolean;
  user: AuthUser;
  tokens: AuthTokens;
  message?: string;
  verificationEmailSent?: boolean;
}

export interface OAuthResponse {
  success: boolean;
  user: AuthUser;
  tokens: AuthTokens;
  isNewUser: boolean;
}

export interface RefreshTokenResponse {
  success: boolean;
  tokens: AuthTokens;
}

export interface EmailVerificationResponse {
  success: boolean;
  message: string;
}

export interface TwoFactorSetupResponse {
  success: boolean;
  secret: string;
  qrCodeUrl: string;
  backupCodes: string[];
}

export interface TwoFactorVerifyResponse {
  success: boolean;
  tokens?: AuthTokens;
  message: string;
}

/**
 * Token Storage Manager
 */
class TokenStorage {
  private static ACCESS_TOKEN_KEY = 'auth_access_token';
  private static REFRESH_TOKEN_KEY = 'auth_refresh_token';
  private static TOKEN_EXPIRY_KEY = 'auth_token_expiry';

  static setTokens(tokens: AuthTokens): void {
    const expiryTime = Date.now() + tokens.expiresIn * 1000;
    localStorage.setItem(this.ACCESS_TOKEN_KEY, tokens.accessToken);
    localStorage.setItem(this.REFRESH_TOKEN_KEY, tokens.refreshToken);
    localStorage.setItem(this.TOKEN_EXPIRY_KEY, expiryTime.toString());
  }

  static getAccessToken(): string | null {
    return localStorage.getItem(this.ACCESS_TOKEN_KEY);
  }

  static getRefreshToken(): string | null {
    return localStorage.getItem(this.REFRESH_TOKEN_KEY);
  }

  static getTokenExpiry(): number | null {
    const expiry = localStorage.getItem(this.TOKEN_EXPIRY_KEY);
    return expiry ? parseInt(expiry, 10) : null;
  }

  static isTokenExpired(): boolean {
    const expiry = this.getTokenExpiry();
    if (!expiry) return true;
    return Date.now() >= expiry - 60000; // Refresh 1 minute before expiry
  }

  static clearTokens(): void {
    localStorage.removeItem(this.ACCESS_TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY);
  }

  static hasValidToken(): boolean {
    return !!this.getAccessToken() && !this.isTokenExpired();
  }
}

/**
 * JWT Token Generator (Client-side simulation)
 * In production, tokens are generated by the backend
 */
class JWTSimulator {
  private static SECRET = 'tattva-co-secret-key'; // Backend secret, not exposed

  static generateMockTokens(userId: number, email: string): AuthTokens {
    // Simulate JWT token generation (in production, this happens on backend)
    const header = { alg: 'HS256', typ: 'JWT' };
    const payload = {
      sub: userId.toString(),
      email,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour
    };

    const accessToken = `${btoa(JSON.stringify(header))}.${btoa(JSON.stringify(payload))}.mock-signature`;
    const refreshToken = `refresh_${btoa(`${userId}-${Date.now()}`)}.mock-refresh-signature`;

    return {
      accessToken,
      refreshToken,
      expiresIn: 3600, // 1 hour
      tokenType: 'Bearer',
    };
  }

  static decodeToken(token: string): any {
    try {
      const parts = token.split('.');
      if (parts.length !== 3) return null;
      const payload = JSON.parse(atob(parts[1]));
      return payload;
    } catch (error) {
      return null;
    }
  }

  static isTokenValid(token: string): boolean {
    const payload = this.decodeToken(token);
    if (!payload) return false;
    return payload.exp * 1000 > Date.now();
  }
}

/**
 * Authentication Service Class
 */
class AuthService {
  private static BASE_URL = '/api/auth'; // Replace with your API URL

  /**
   * Login with email and password
   */
  static async login(
    email: string,
    password: string,
    rememberMe: boolean = false
  ): Promise<LoginResponse> {
    try {
      // In production, replace with actual API call:
      // const response = await fetch(`${this.BASE_URL}/login`, {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ email, password, rememberMe }),
      // });
      // return await response.json();

      // Mock implementation for demo
      await this.simulateNetworkDelay();

      // Simulate validation
      if (email === 'anika.sharma@example.com' && password === 'password123') {
        const user: AuthUser = {
          id: 1,
          email,
          name: 'Anika Sharma',
          isAdmin: true,
          isEmailVerified: true,
          has2FA: false,
        };

        const tokens = JWTSimulator.generateMockTokens(user.id, user.email);
        TokenStorage.setTokens(tokens);

        return {
          success: true,
          user,
          tokens,
          message: 'Login successful',
        };
      }

      // Check if 2FA is required (mock)
      if (email.includes('2fa')) {
        return {
          success: false,
          requires2FA: true,
          message: '2FA verification required',
          user: null as any,
          tokens: null as any,
        };
      }

      throw new Error('Invalid email or password');
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Login failed');
    }
  }

  /**
   * Sign up new user
   */
  static async signUp(name: string, email: string, password: string): Promise<SignUpResponse> {
    try {
      // Mock implementation
      await this.simulateNetworkDelay(1000);

      const user: AuthUser = {
        id: Date.now(),
        email,
        name,
        isAdmin: false,
        isEmailVerified: false,
        has2FA: false,
      };

      const tokens = JWTSimulator.generateMockTokens(user.id, user.email);
      TokenStorage.setTokens(tokens);

      return {
        success: true,
        user,
        tokens,
        message: 'Account created successfully',
        verificationEmailSent: true,
      };
    } catch (error) {
      throw new Error('Sign up failed');
    }
  }

  /**
   * Logout
   */
  static async logout(): Promise<void> {
    try {
      // In production, call backend to invalidate refresh token
      // await fetch(`${this.BASE_URL}/logout`, {
      //   method: 'POST',
      //   headers: { Authorization: `Bearer ${TokenStorage.getAccessToken()}` },
      // });

      TokenStorage.clearTokens();
    } catch (error) {
      // Clear tokens anyway
      TokenStorage.clearTokens();
    }
  }

  /**
   * Refresh access token
   */
  static async refreshAccessToken(): Promise<RefreshTokenResponse> {
    try {
      const refreshToken = TokenStorage.getRefreshToken();
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }

      // Mock implementation
      await this.simulateNetworkDelay(300);

      // Decode old token to get user info
      const oldToken = TokenStorage.getAccessToken();
      const payload = oldToken ? JWTSimulator.decodeToken(oldToken) : null;

      if (!payload) {
        throw new Error('Invalid token');
      }

      const tokens = JWTSimulator.generateMockTokens(parseInt(payload.sub), payload.email);
      TokenStorage.setTokens(tokens);

      return {
        success: true,
        tokens,
      };
    } catch (error) {
      TokenStorage.clearTokens();
      throw new Error('Token refresh failed');
    }
  }

  /**
   * Get current user from token
   */
  static async getCurrentUser(): Promise<AuthUser | null> {
    try {
      const token = TokenStorage.getAccessToken();
      if (!token || TokenStorage.isTokenExpired()) {
        // Try to refresh token
        if (TokenStorage.getRefreshToken()) {
          await this.refreshAccessToken();
        } else {
          return null;
        }
      }

      // In production, call backend to get user data
      // const response = await fetch(`${this.BASE_URL}/me`, {
      //   headers: { Authorization: `Bearer ${TokenStorage.getAccessToken()}` },
      // });
      // return await response.json();

      // Mock implementation
      const payload = JWTSimulator.decodeToken(token!);
      return {
        id: parseInt(payload.sub),
        email: payload.email,
        name: 'Anika Sharma',
        isAdmin: true,
        isEmailVerified: true,
        has2FA: false,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * OAuth Login
   */
  static async oauthLogin(provider: 'google' | 'facebook', code: string): Promise<OAuthResponse> {
    try {
      // Mock implementation
      await this.simulateNetworkDelay(800);

      const user: AuthUser = {
        id: Date.now(),
        email: `user@${provider}.com`,
        name: `${provider.charAt(0).toUpperCase() + provider.slice(1)} User`,
        isAdmin: false,
        isEmailVerified: true, // OAuth providers verify email
        has2FA: false,
        profilePicture: `https://via.placeholder.com/150?text=${provider}`,
      };

      const tokens = JWTSimulator.generateMockTokens(user.id, user.email);
      TokenStorage.setTokens(tokens);

      return {
        success: true,
        user,
        tokens,
        isNewUser: Math.random() > 0.5, // Random for demo
      };
    } catch (error) {
      throw new Error('OAuth login failed');
    }
  }

  /**
   * Request email verification
   */
  static async sendVerificationEmail(email: string): Promise<EmailVerificationResponse> {
    try {
      await this.simulateNetworkDelay(500);

      return {
        success: true,
        message: 'Verification email sent',
      };
    } catch (error) {
      throw new Error('Failed to send verification email');
    }
  }

  /**
   * Verify email with token
   */
  static async verifyEmail(token: string): Promise<EmailVerificationResponse> {
    try {
      await this.simulateNetworkDelay(500);

      return {
        success: true,
        message: 'Email verified successfully',
      };
    } catch (error) {
      throw new Error('Email verification failed');
    }
  }

  /**
   * Setup 2FA
   */
  static async setup2FA(): Promise<TwoFactorSetupResponse> {
    try {
      await this.simulateNetworkDelay(500);

      // Generate mock secret and QR code
      const secret = this.generateTOTPSecret();
      const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=otpauth://totp/TattvaCo:user@example.com?secret=${secret}&issuer=TattvaCo`;
      const backupCodes = this.generateBackupCodes();

      return {
        success: true,
        secret,
        qrCodeUrl,
        backupCodes,
      };
    } catch (error) {
      throw new Error('Failed to setup 2FA');
    }
  }

  /**
   * Verify 2FA code
   */
  static async verify2FA(code: string, userId: number): Promise<TwoFactorVerifyResponse> {
    try {
      await this.simulateNetworkDelay(500);

      // Mock validation (any 6-digit code works)
      if (!/^\d{6}$/.test(code)) {
        return {
          success: false,
          message: 'Invalid code format',
        };
      }

      const tokens = JWTSimulator.generateMockTokens(userId, 'user@example.com');
      TokenStorage.setTokens(tokens);

      return {
        success: true,
        tokens,
        message: '2FA verification successful',
      };
    } catch (error) {
      throw new Error('2FA verification failed');
    }
  }

  /**
   * Disable 2FA
   */
  static async disable2FA(password: string): Promise<{ success: boolean; message: string }> {
    try {
      await this.simulateNetworkDelay(500);

      return {
        success: true,
        message: '2FA disabled successfully',
      };
    } catch (error) {
      throw new Error('Failed to disable 2FA');
    }
  }

  /**
   * Helper: Simulate network delay
   */
  private static simulateNetworkDelay(ms: number = 500): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Helper: Generate TOTP secret
   */
  private static generateTOTPSecret(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    let secret = '';
    for (let i = 0; i < 32; i++) {
      secret += chars[Math.floor(Math.random() * chars.length)];
    }
    return secret;
  }

  /**
   * Helper: Generate backup codes
   */
  private static generateBackupCodes(): string[] {
    const codes: string[] = [];
    for (let i = 0; i < 10; i++) {
      const code = Math.random().toString(36).substring(2, 10).toUpperCase();
      codes.push(code);
    }
    return codes;
  }
}

export { AuthService, TokenStorage, JWTSimulator };
