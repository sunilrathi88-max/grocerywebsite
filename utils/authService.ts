/**
 * Authentication Service
 * Handles JWT tokens, authentication state, and API integration
 */

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number; // seconds
  tokenType: 'Bearer';
}

export interface AuthUser {
  id: number;
  email: string;
  name: string;
  isAdmin: boolean;
  isEmailVerified: boolean;
  has2FA: boolean;
  profilePicture?: string;
  createdAt?: string;
}

export interface LoginResponse {
  success: boolean;
  user: AuthUser;
  tokens: AuthTokens;
  message?: string;
  requires2FA?: boolean;
}

export interface SignUpResponse {
  success: boolean;
  user: AuthUser;
  tokens: AuthTokens;
  message?: string;
  verificationEmailSent?: boolean;
}

export interface OAuthResponse {
  success: boolean;
  user: AuthUser;
  tokens: AuthTokens;
  isNewUser: boolean;
}

export interface RefreshTokenResponse {
  success: boolean;
  tokens: AuthTokens;
}

export interface EmailVerificationResponse {
  success: boolean;
  message: string;
}

export interface TwoFactorSetupResponse {
  success: boolean;
  secret: string;
  qrCodeUrl: string;
  backupCodes: string[];
}

export interface TwoFactorVerifyResponse {
  success: boolean;
  tokens?: AuthTokens;
  message: string;
}

/**
 * Token Storage Manager
 */
class TokenStorage {
  private static ACCESS_TOKEN_KEY = 'auth_access_token';
  private static REFRESH_TOKEN_KEY = 'auth_refresh_token';
  private static TOKEN_EXPIRY_KEY = 'auth_token_expiry';

  static setTokens(tokens: AuthTokens): void {
    const expiryTime = Date.now() + tokens.expiresIn * 1000;
    localStorage.setItem(this.ACCESS_TOKEN_KEY, tokens.accessToken);
    localStorage.setItem(this.REFRESH_TOKEN_KEY, tokens.refreshToken);
    localStorage.setItem(this.TOKEN_EXPIRY_KEY, expiryTime.toString());
  }

  static getAccessToken(): string | null {
    return localStorage.getItem(this.ACCESS_TOKEN_KEY);
  }

  static getRefreshToken(): string | null {
    return localStorage.getItem(this.REFRESH_TOKEN_KEY);
  }

  static getTokenExpiry(): number | null {
    const expiry = localStorage.getItem(this.TOKEN_EXPIRY_KEY);
    return expiry ? parseInt(expiry, 10) : null;
  }

  static isTokenExpired(): boolean {
    const expiry = this.getTokenExpiry();
    if (!expiry) return true;
    return Date.now() >= expiry - 60000; // Refresh 1 minute before expiry
  }

  static clearTokens(): void {
    localStorage.removeItem(this.ACCESS_TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);
    localStorage.removeItem(this.TOKEN_EXPIRY_KEY);
  }

  static hasValidToken(): boolean {
    return !!this.getAccessToken() && !this.isTokenExpired();
  }
}

/**
 * JWT Token Decoder (Client-side utility)
 * Tokens are generated by the backend only
 */
class JWTDecoder {
  static decodeToken(token: string): any {
    try {
      const parts = token.split('.');
      if (parts.length !== 3) return null;
      const base64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');
      let decoded: string;
      if (typeof globalThis.atob === 'function') {
        decoded = globalThis.atob(base64);
      } else if (typeof (globalThis as any).Buffer !== 'undefined') {
        decoded = (globalThis as any).Buffer.from(base64, 'base64').toString('utf-8');
      } else {
        return null;
      }
      const payload = JSON.parse(decoded);
      return payload;
    } catch (_error) {
      return null;
    }
  }

  static isTokenValid(token: string): boolean {
    const payload = this.decodeToken(token);
    if (!payload) return false;
    return payload.exp * 1000 > Date.now();
  }
}

/**
 * Authentication Service Class
 */
class AuthService {
  private static get BASE_URL(): string {
    return import.meta.env.VITE_API_URL || 'http://localhost:5000';
  }

  /**
   * Helper: Make authenticated API request
   */
  private static async apiRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const url = `${this.BASE_URL}${endpoint}`;
    const token = TokenStorage.getAccessToken();

    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      ...options.headers,
    };

    if (token && !options.headers?.['Authorization']) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    const response = await fetch(url, {
      ...options,
      headers,
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: 'Request failed' }));
      throw new Error(error.message || `HTTP ${response.status}`);
    }

    return response.json();
  }

  /**
   * Login with email and password
   */
  static async login(
    email: string,
    password: string,
    rememberMe: boolean = false
  ): Promise<LoginResponse> {
    try {
      const { supabase } = await import('../supabaseClient');
      const { data, error } = await supabase.auth.signInWithPassword({ email, password });
      if (error || !data.session || !data.user) {
        throw new Error(error?.message || 'Invalid email or password');
      }

      const tokens: AuthTokens = {
        accessToken: data.session.access_token,
        refreshToken: data.session.refresh_token ?? '',
        expiresIn: data.session.expires_in ?? 3600,
        tokenType: 'Bearer',
      };
      TokenStorage.setTokens(tokens);

      const user: AuthUser = {
        id: 0,
        email: data.user.email || '',
        name: data.user.user_metadata?.name || data.user.email || '',
        isAdmin: Boolean(data.user.user_metadata?.is_admin),
        isEmailVerified: Boolean(data.user.email_confirmed_at),
        has2FA: false,
      };

      return { success: true, user, tokens };
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Login failed');
    }
  }

  /**
   * Sign up new user
   */
  static async signUp(name: string, email: string, password: string): Promise<SignUpResponse> {
    try {
      const { supabase } = await import('../supabaseClient');
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: { data: { name } },
      });
      if (error || !data.user) {
        throw new Error(error?.message || 'Sign up failed');
      }

      // Supabase may or may not create a session depending on email confirmation settings
      const tokens: AuthTokens = {
        accessToken: data.session?.access_token ?? '',
        refreshToken: data.session?.refresh_token ?? '',
        expiresIn: data.session?.expires_in ?? 0,
        tokenType: 'Bearer',
      };
      if (tokens.accessToken) TokenStorage.setTokens(tokens);

      const user: AuthUser = {
        id: 0,
        email: data.user.email || '',
        name: name || data.user.email || '',
        isAdmin: false,
        isEmailVerified: Boolean(data.user.email_confirmed_at),
        has2FA: false,
      };

      return { success: true, user, tokens, verificationEmailSent: !tokens.accessToken };
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Sign up failed');
    }
  }

  /**
   * Logout
   */
  static async logout(): Promise<void> {
    try {
      const { supabase } = await import('../supabaseClient');
      await supabase.auth.signOut();
      TokenStorage.clearTokens();
    } catch (_error) {
      // Clear tokens anyway
      TokenStorage.clearTokens();
    }
  }

  /**
   * Refresh access token
   */
  static async refreshAccessToken(): Promise<RefreshTokenResponse> {
    try {
      const refreshToken = TokenStorage.getRefreshToken();
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }

      const response = await this.apiRequest<RefreshTokenResponse>('/api/auth/refresh', {
        method: 'POST',
        body: JSON.stringify({ refreshToken }),
      });

      if (response.success && response.tokens) {
        TokenStorage.setTokens(response.tokens);
      }

      return response;
    } catch (error) {
      TokenStorage.clearTokens();
      throw new Error(error instanceof Error ? error.message : 'Token refresh failed');
    }
  }

  /**
   * Get current user from token
   */
  static async getCurrentUser(): Promise<AuthUser | null> {
    try {
      const token = TokenStorage.getAccessToken();
      if (!token || TokenStorage.isTokenExpired()) {
        // Try to refresh token
        if (TokenStorage.getRefreshToken()) {
          await this.refreshAccessToken();
        } else {
          return null;
        }
      }

      const response = await this.apiRequest<AuthUser>('/api/auth/me', {
        method: 'GET',
      });

      return response;
    } catch (_error) {
      return null;
    }
  }

  /**
   * OAuth Login
   */
  static async oauthLogin(provider: 'google' | 'facebook', code: string): Promise<OAuthResponse> {
    try {
      const response = await this.apiRequest<OAuthResponse>(`/api/auth/oauth/${provider}`, {
        method: 'POST',
        body: JSON.stringify({ code }),
      });

      if (response.success && response.tokens) {
        TokenStorage.setTokens(response.tokens);
      }

      return response;
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'OAuth login failed');
    }
  }

  /**
   * Request email verification
   */
  static async sendVerificationEmail(email: string): Promise<EmailVerificationResponse> {
    try {
      const response = await this.apiRequest<EmailVerificationResponse>(
        '/api/auth/send-verification',
        {
          method: 'POST',
          body: JSON.stringify({ email }),
        }
      );

      return response;
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Failed to send verification email');
    }
  }

  /**
   * Verify email with token
   */
  static async verifyEmail(token: string): Promise<EmailVerificationResponse> {
    try {
      const response = await this.apiRequest<EmailVerificationResponse>('/api/auth/verify-email', {
        method: 'POST',
        body: JSON.stringify({ token }),
      });

      return response;
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Email verification failed');
    }
  }

  /**
   * Setup 2FA
   */
  static async setup2FA(): Promise<TwoFactorSetupResponse> {
    try {
      const response = await this.apiRequest<TwoFactorSetupResponse>('/api/auth/2fa/setup', {
        method: 'POST',
      });

      return response;
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Failed to setup 2FA');
    }
  }

  /**
   * Verify 2FA code
   */
  static async verify2FA(code: string, userId: number): Promise<TwoFactorVerifyResponse> {
    try {
      const response = await this.apiRequest<TwoFactorVerifyResponse>('/api/auth/2fa/verify', {
        method: 'POST',
        body: JSON.stringify({ code, userId }),
      });

      if (response.success && response.tokens) {
        TokenStorage.setTokens(response.tokens);
      }

      return response;
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : '2FA verification failed');
    }
  }

  /**
   * Disable 2FA
   */
  static async disable2FA(password: string): Promise<{ success: boolean; message: string }> {
    try {
      const response = await this.apiRequest<{ success: boolean; message: string }>(
        '/api/auth/2fa/disable',
        {
          method: 'POST',
          body: JSON.stringify({ password }),
        }
      );

      return response;
    } catch (error) {
      throw new Error(error instanceof Error ? error.message : 'Failed to disable 2FA');
    }
  }
}

export { AuthService, TokenStorage, JWTDecoder };
